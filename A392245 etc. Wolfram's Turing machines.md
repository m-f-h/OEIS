---
permalink: /A392245/
title: "A392245 et al.: Wolfram's Turing machines"
---
# A392245 et al.: Wolfram's Turing machines

Refs:
* S.W.: [P vs. NP and the Difficulty of Computation: A Ruliological Approach](https://writings.stephenwolfram.com/2026/01/p-vs-np-and-the-difficulty-of-computation-a-ruliological-approach/), Jan 2026
* Wolfram Atlas: [Machine 261 - Rule properties](https://atlas.wolfram.com/03/01/261/03_01_1_261.html#03_01_114_261)

Define a Turing machine (TM) through a transition table { si: osm } where si = state + input, osm = output+state+move.

This TM acts on integers as follows: it starts at position p=0, 
where the position tells which bit of the integer is read as input, and possibly changed as output.

Then the machine will move to position p+1 if move m = L (= 0) or to position p-1 if move m = R (= 1).

The machine stops if the position becomes negative. 

This yields a result (the modified integer) and a "run time" = the number of moves made.
(TO DO: double-check whether the final move to position -1 is counted or not.)


A392245

The state transitions are: 1D -> 1DL, 0D -> 0DL, 1U -> 0DL, 0U -> 0UR, 
where the notation 1D -> 1DL means if the cell under the head is 1 and the head is in the down state, 
then that cell remains 1, the head remains down, and the head moves to the left.


Related sequences: A392245, ...

## Programs
```(Python)
class TM(dict):
   """The TM is a dict that holds the transition table {(in, state): (out, state, move)}
and additional state parameters 'pos' and 'state' (also available as T.pos and T.state).
At initialization, the table can be given as a dict with numerical or string entries,
or a single string like "1D: 1DL, 0D: 0DL, 1U: 0DL, 0U: 0UR", or as kwargs (D1='1DL', ...).
If provided as string(s), `in` and `out` must be digits, and 'state' must be letters
different from 'L' and 'R', which are reserved for `move`. (E.g., 'U','D' or 'A', 'B', 'C').
Internally, the transition table is then stored with tuples of integers >= 0
(except for 'move' which is -1 for 'R'), where `state` are the indices to
`T.states` which lists the given state symbols in order of appearance.

If called as T(n), it returns the new integer n' resulting from making one iteration on n's bitmap.
T.pos and T.state will change accordingly. If T.pos < 0, StopIteration is raised.
The method `T.run(n)` runs the machine until it stops or enters an infinite loop, and
returns (final_n, num_iterations), where `num_iterations` = -1 if an infinite loop was detected,
in which case `final_n` = -1 if n did not converge (grows to oo or oscillates).
"""
   def __init__(self, data=None, **kwargs):
      if isinstance(data, str):
         sep = next(s for s in ('->', ':', '>', ' ', '') if s in data)
         if not sep: raise ValueError("Use -> or : or space to define the mapping.")
         data = {kv[0].strip(): kv[-1].strip() for pair in data.split(',')
                 if (kv := pair.strip().split(sep))}
      elif data is None: data = kwargs
      self.states = ''
      for key,value in data.items():
        if len(key) == 2:
           #else: raise ValueError(f"Expected (state, symbol_read), got {key!r}.")
           if len(value) != 3: raise ValueError(f"Expected (state, symbol_write, move), got {value!r}.")
           if isinstance(key, str):  key = self.str2num(key)
           if isinstance(value, str): value = self.str2num(value)
        self[key] = value
      if not self.states: self.states='ABCDEF'
      # default values
      for k,v in {'pos':0, 'state': 0}.items():
         if k not in self: self[k]=v
   def str2num(self, s: str):
      "Return numerical version of (read, state) or (write, state, move)."
      s = sorted(s.upper()) # digit first
      if not s[0].isdigit(): raise ValueError(f"No digit in {s}'!")
      if len(s) > 2:
        for move in 'LR':
          if move in s: del s[s.index(move)]; break
        else: raise ValueError(f"No move (L/R) found in {s}.")
        s.append(1 if move=='L' else -1)
      # now s = [ in_out_digit, state_letter, [move_integer] ]
      if s[1] not in self.states: self.states += s[1]
      s[0] = int(s[0]) ; s[1] = self.states.index(s[1])
      return tuple(s)
   def __call__(self, n):
      """Apply the TM in its current state to a n's bits, return the new n."""
      if self.pos < 0: raise StopIteration
      input = (n >> self.pos) & 1
      out, self.state, move = self[input, self.state]
      if out != input: n ^= 1 << self.pos
      self.pos += move
      return n
   MAX_ITER = 99
   def run(self, n):
      "Apply the TM to n until position < 0; return (final n, number of iterations)."
      for iter in range(MAX_ITER):
         if self.pos < 0: return n, iter
         n = self(n)
      return (n if self.pos > bit_length(n)+2 else -1, -iter)
   def seq(self, n):
      "Yield the sequence of numbers produced by iterating `self` on the starting value `n`." 
      ...
   def reset(self): return self.state = self.pos = 0
   def num2str(self, s):
      "Convert (in,state) or (out,state,move) to string. Return s if not a tuple."
      return f"{s[0]}{self.states[s[1]]}{''if len(s)<3 else 'L' if s[2]>0 else 'R'}" if isinstance(s, tuple) else s 

   def as_str(self): return {self.num2str(k):self.num2str(v) for k,v in self.items() if k!='states'}
   def __repr__(self): return f"TM('{", ".join(f"{k}: {v}" for k,v in self.as_str().items())}')"
   #def __str__(self): return str(self.as_str())
   __str__=__repr__
   # to use self.pos instead self['pos'] etc.:
   def __getattr__(self, key): return self[key]
   def __setattr__(self, key, value): self[key] = value

   def rule_number(self): # return Wolfram's rule number
      return sum( (out*4 + state*2 + (move<0)) << 3*k
                  for k,(out,state,move) in enumerate(self.values()))
   
if 1:
 T = TM("1U -> 1UL, 0U -> 0DL, 1D -> 0UL, 0D -> 0DR")
 for n in range(1,9):
  T.pos=T.state=0
  seq = [(k:=T(k)if i else n, T.pos) for i in range(9) if T.pos>=0]
  print(" => ".join(f"{k:b}[{p}]" for k,p in seq))


ii = sorted(T)
def toc(a,b,c):return a*4+b+2*(1-max(c,0))
sum(toc(*T[i])*8**j for j,i in enumerate(ii))
280

(PARI)
T392245=TM_create("1D -> 1DL, 0D -> 0DL, 1U -> 0DL, 0U -> 0UR") \\the TM
A392245(n)=T392245.runtime(n)
TM.runtime = n-> mapput(TM,'pos',0); for(i=0,oo, n=TM.act(n); p<0 && return(i))
TM.act(n, pos) = my(input = bittest(n, pos),osm=TM[input + 2*TM.state]

```

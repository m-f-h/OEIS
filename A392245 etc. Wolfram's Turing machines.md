permalink: /A392245/
title: A392245 et al.: Wolfram's Turing machines
---
# A392245 et al.: Wolfram's Turing machines

Define a Turing machine (TM) through a transition table { si: osm } where si = state + input, osm = output+state+move.

This TM acts on integers as follows: it starts at position p=0, 
where the position tells which bit of the integer is read as input, and possibly changed as output.

Then the machine will move to position p+1 if move m = L (= 0) or to position p-1 if move m = R (= 1).

The machine stops if the position becomes negative. 

This yields a result (the modified integer) and a "run time" = the number of moves made.
(TO DO: double-check whether the final move to position -1 is counted or not.)


A392245

The state transitions are: 1D -> 1DL, 0D -> 0DL, 1U -> 0DL, 0U -> 0UR, 
where the notation 1D -> 1DL means if the cell under the head is 1 and the head is in the down state, 
then that cell remains 1, the head remains down, and the head moves to the left.


Related sequences: A392245, ...

## Programs
```(Python)
class TM(dict):
   """The TM is a dict that has keys (state, in) and values (write, state, move).
All of these are nonnegative integers except for move which can be negative (= move right).
It can be given as such, OR with keys and values given as strings (move = L or R,
in/write = digits, and state = letters ('U', 'D', ... or 'A', 'B', 'C', ...),
OR as a single string where the different key-value pairs are separated by commas ','
and keys are separated from values by ':' or '->' or ' '.
The key-value pairs can also be provided as keyword arguments.
"""
   def __init__(self, data=None, **kwargs):
      if isinstance(data, str):
         sep = next(s for s in ('->',':','>',' ','') if s in data)
         if not sep: raise ValueError("Use -> or : or space to define the mapping.")
         data = {kv[0].strip(): kv[-1].strip() for pair in data.split(',')
                 if (kv := pair.strip().split(sep))}
      elif data is None: data = kwargs
      self.states = ''
      for key,value in data.items():
        if len(key) != 2: raise ValueError(f"Expected (state, symbol_read), got {key!r}.")
        if len(value) != 3: raise ValueError(f"Expected (state, symbol_write, move), got {value!r}.")
        if isinstance(key, str):  key = self.str2num(key)
        if isinstance(value, str): value = self.str2num(value)
        self[key] = value
      if not self.states: self.states='ABCDEF'
   def str2num(self, s):
      "Return numerical version of (read, state) or (write, state, move)."
      s = sorted(s.upper()) # digit first
      if len(s) > 2:
        for move in 'LR':
          if move in s: del s[s.index(move)]; break
        else: ValueError(f"No move (L/R) found in {s}.")
        s.append(1 if move=='L' else -1)
      if s[1] not in self.states: self.states += s[1]
      s[0] = int(s[0]) ; s[1] = self.states.index(s[1])
      return tuple(s)
   def __call__(self, n):
      pos = state = iter = 0
      while pos >= 0:
        write, state, move = self[ read := (n>>pos)&1, state ]
        if read != write: n ^= 1 << pos
        pos += move ; iter += 1 ; iter > 99 and 1/0
      return n, iter
   def num2str(self, s):
      return f"{s[0]}{self.states[s[1]]}{''if len(s)<3 else 'L' if s[2]>0 else 'R'}"
   def __str__(self): return str({self.num2str(k):self.num2str(v) for k,v in self.items()})

T = TM("1D -> 1DL, 0D -> 0DL, 1U -> 0DL, 0U -> 0UR")
ii = sorted(T)
def toc(a,b,c):return a*4+b+2*(1-max(c,0))
sum(toc(*T[i])*8**j for j,i in enumerate(ii))
280

(PARI)
T392245=TM_create("1D -> 1DL, 0D -> 0DL, 1U -> 0DL, 0U -> 0UR") \\the TM
A392245(n)=T392245.runtime(n)
TM.runtime = n-> mapput(TM,'pos',0); for(i=0,oo, n=TM.act(n); p<0 && return(i))
TM.act(n, pos) = my(input = bittest(n, pos),osm=TM[input + 2*TM.state]

```

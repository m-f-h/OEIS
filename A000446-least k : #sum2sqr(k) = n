oeis.org/A000446: Smallest number that is the sum of 2 squares (allowing zeros) in exactly n ways.
= 0, 25, 325, 1105, 4225, 5525, 203125, 27625, 71825, 138125, 2640625, 160225, 17850625, 1221025, 1795625, 801125, 1650390625, 2082925, 49591064453125, 4005625, 44890625, 2158203125, 30525625, 5928325, 303460625, 53955078125 

See also: oeis.org/A000448 (...in at least n ways)

An algorithm to compute the n-th term of this sequence for n>1: Write each of 2n and 2n-1 as products of their divisors, in decreasing order and in all possible ways. Equate each divisor in the product to (a1+1)(a2+1)...(ar+1), so that a1>=a2>=a3>=...>=ar, and solve for the ai. Evaluate A002144(1)^a1 x A002144(2)^a2 x ... x A002144(r)^ar for each set of values determined above, then the smaller of these products is the least integer to have precisely n partitions into a sum of two squares. [Ant King, Oct 07 2010]

Example: n = 2. 2n = 4 = [[4], [2,2]] and 2n-1 = 3 = [[3]].
For 4 = (a1+1) => a1 = 3 => A2144(1)^3 = 125
For 2*2 = (a1+1)(a2+1) => a1 = a2 = 1 => A2144(1)^1 * A2144(2)^1 = 5*13 = 
For 3 = (a1+1) => a1 = 2 => A2144(1)^2 = 5^2 = 25. 

Example n = 4: 2n = 8 = [[8], [4, 2], [2, 2, 2]] ; 2n-1 = 7 = [[7]]
For 7 = (a1+1) => a1 = 6 => A2144(1)^6 = 5^6
For 4*2 = (a1+1)(a2+1) => a1 = 3, a2 = 1 => A2144(1)^3 * A2144(2)^1 = 5^3 * 13
For 2*2*2 = (a1+1)(a2+1)(a3+1) => a1 = a2 = a3 = 1 => A2144(1) * A2144(2) * A2144(3) *  = 5 * 13 * 17 <==

PARI/GP:

A000446(n) =
vecmin([ prod(i=1, #a, A002144(i)^(a[i]-1)) | a <- concat([prod_of_div(n*2), prod_of_div(n*2-1)]) ])

/* Write n in all possible ways as product of its divisors d = (1, p1, p2, ..., n/p1, n).
   i.e.:  n = n = (n/p1)*p1 = (n/p2)*p2 = (n/(p1*p2))* p2 * p1 = ...
   So, we start with the largest divisor d[#d] = n ; then, d[#d-1] * d[2],
   etc.:  when we're down to d[#d-k], we have to write d[1+k]  in all possible ways
   using only smaller divisors.
 @param d: list of "admissible" divisors of n. They must be <= n and > 1.
*/
prod_of_div(n, L = n, D = Vecrev( divisors(n)[^1] )) = { D || return(D);
  concat( vector( #D, i, if( D[i] > L, [], D[i] == n, [[n]],
                             [ concat(D[i], P) | P <- prod_of_div( n/D[i], D[i] )]) ))}

A002144(n)= while(#A2144<n, extend()); A2144[n]
/* Pythagorean primes: primes of form 4*k + 1. (Formerly M3823 N1566) */
A2144=List([ 5, 13, 17, 29, 37, 41, 53, 61, 73, 89,   97, 101, 109, 113, 137, 149, 157, 173, 181, 193,{
  197, 229, 233, 241, 257, 269, 277, 281, 293, 313,  317, 337, 349, 353, 373, 389, 397, 401, 409, 421,
  433, 449, 457, 461, 509, 521, 541, 557, 569, 577,  593, 601, 613, 617 }])

/* compact version: */

PD(n, L=n, D=Vecrev(divisors(n)[^1])) = { if(D, concat(vector(#D, i, if(D[i] > L, [], D[i] < n, [concat(D[i], P) | P <- PD(n/D[i], D[i])], [[n]]))), D)}

apply( {A000446(n)=vecmin(if(n>1, [prod(i=1, #a, A002144(i)^(a[i]-1)) | a<-concat([PD(n*2)[^1], PD(n*2-1)])]))}, [1..44]) \\ _M. F. Hasler_, Jul 06 2024

/*************  timings ************/

(17:58) gp > for(k=1,1e3,A000446(k))
  ***   last result computed in 109 ms.
(18:00) gp > for(k=1,1e4,A000446(k))
time = 2,955 ms.

/**** compare to this variant: ****/

a(n) = if(n>1, min(A018782(2*n-1), A018782(2*n)) )

primelist(d,r,l) =
my(v=vector(l),i=0);if(l>0,forprime(p=2,oo,if(Mod(p,d)==r,i++;v[i]=p;if(i==l,break()))));v

prodR = 
(n,maxf)->my(dfs=divisors(n),a=[],r);for(i=2,#dfs,if(dfs[i]<=maxf,if(dfs[i]==n,a=concat(a,[[n]]),r=prodR(n/dfs[i],min(dfs[i],maxf));for(j=1,#r,a=concat(a,[concat(dfs[i],r[j])])))));a

A018782(n) = 
my(pf=prodR(n,n), a=1, b, v=primelist(4,1,bigomega(n))); for(i=1,#pf, b=prod(j=1,length(pf[i]), v[j]^(pf[i][j]-1)); if(b<a||i==1,a=b));a

(18:01) gp > for(k=1,1e3,a(k))
time = 250 ms.
(18:01) gp > for(k=1,1e4,a(k))
time = 8,828 ms.

/************  conclusion : a(n) is ~ 2.5 times slower ************/
